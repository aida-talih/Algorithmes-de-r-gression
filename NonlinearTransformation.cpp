#include<bits/stdc++.h>

using namespace std;


int main()
{



 double x1[]={0.051267 , -0.092742 , -0.21371   -0.375  ,   -0.51325 ,  -0.52477,
    -0.39804  , -0.30588  ,  0.016705  , 0.13191  ,  0.38537  ,  0.52938,
     0.63882  ,  0.73675  ,  0.54666   , 0.322    ,  0.16647  , -0.046659,
    -0.17339  , -0.47869  , -0.60541  , -0.62846  , -0.59389  , -0.42108,
    -0.11578  ,  0.20104  ,  0.46601  ,  0.67339  , -0.13882  , -0.29435,
    -0.26555  , -0.16187  , -0.17339  , -0.28283  , -0.36348  , -0.30012,
    -0.23675  , -0.06394  ,  0.062788 ,  0.22984  ,  0.2932   ,  0.48329,
     0.64459  ,  0.46025  ,  0.6273   ,  0.57546   , 0.72523  ,  0.22408,
     0.44297  ,  0.322    ,  0.13767  , -0.0063364 ,-0.092742 , -0.20795,
    -0.20795  , -0.43836  , -0.21947  , -0.13882  ,  0.18376  ,  0.22408,
     0.29896  ,  0.50634  ,  0.61578  ,  0.60426  ,  0.76555  ,  0.92684,
     0.82316  ,  0.96141  ,  0.93836  ,  0.86348  ,  0.89804  ,  0.85196,
     0.82892  ,  0.79435  ,  0.59274  ,  0.51786  ,  0.46601  ,  0.35081,
     0.28744  ,  0.085829 ,  0.14919  , -0.13306  , -0.40956  , -0.39228,
    -0.74366  , -0.69758  , -0.75518  , -0.69758  , -0.4038   , -0.38076,
    -0.50749  , -0.54781  ,  0.10311  ,  0.057028 , -0.10426  , -0.081221,
     0.28744  ,  0.39689  ,  0.63882  ,  0.82316   , 0.67339  ,  1.0709,
    -0.046659 , -0.23675  , -0.15035  , -0.49021  , -0.46717  , -0.28859,
    -0.61118  , -0.66302  , -0.59965  , -0.72638 ,  -0.83007  , -0.72062,
    -0.59389  , -0.48445  , -0.0063364 , 0.63265  };

double x2[]={0.69956  , 0.68494 , 0.69225  , 0.50219  , 0.46564  , 0.2098   , 0.034357,
    -0.19225 , -0.40424  ,-0.51389 , -0.56506  ,-0.5212 ,  -0.24342 , -0.18494,
     0.48757 ,  0.5826   , 0.53874 ,  0.81652  , 0.69956 ,  0.63377 ,  0.59722,
     0.33406 ,  0.005117 ,-0.27266 , -0.39693  ,-0.60161 , -0.53582 , -0.53582,
     0.54605 ,  0.77997  , 0.96272 ,  0.8019   , 0.64839 ,  0.47295 ,  0.31213,
     0.027047, -0.21418  ,-0.18494 , -0.16301  ,-0.41155 , -0.2288  , -0.18494,
    -0.14108 , 0.012427  , 0.15863 , 0.26827  ,0.44371 ,  0.52412 ,  0.67032,
     0.69225 ,  0.57529  , 0.39985 ,  0.55336  , 0.35599 ,  0.17325 ,  0.21711,
    -0.016813, -0.27266  , 0.93348 ,  0.77997  , 0.61915 ,  0.75804 ,  0.7288,
     0.59722 ,  0.50219  , 0.3633  ,  0.27558  , 0.085526,  0.012427, -0.082602,
    -0.20687 , -0.36769  ,-0.5212  , -0.55775  ,-0.7405  , -0.5943  , -0.41886,
    -0.57968 , -0.76974  ,-0.75512 , -0.57968  ,-0.4481  , -0.41155 , -0.25804,
    -0.25804 ,  0.041667 , 0.2902  ,  0.68494  , 0.70687 ,  0.91886 ,  0.90424,
     0.70687 ,  0.77997  , 0.91886 ,  0.99196  , 1.1089  ,  1.087   ,  0.82383,
     0.88962 ,  0.66301  , 0.64108 ,  0.10015  ,-0.57968 , -0.63816 , -0.36769,
    -0.3019  , -0.13377  ,-0.060673, -0.067982 ,-0.21418 , -0.41886  ,-0.082602,
    0.31213  , 0.53874   , 0.49488 ,  0.99927  , 0.99927 , -0.030612};
double y[]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
double f;

double m[28][118];
int cpt=0;


//map feature

for (int q = 0 ;q <= 6 ; q++)
{
    for (int p = 0 ; p < q+1 ; p++ )
    {
        //cout << q-p << " ," << p <<endl;
        for(int k=0;k<118;k++){
            m[cpt][k]= pow(x1[k], q-p) * pow(x2[k], p);

        }

        cpt++;
    }
}


double x[118][28];
/*
for(int i=0;i<118;i++){

    x[i][0]=1;

}
for(int i=0;i<118;i++){

    x[i][1]=x1[i];

}
for(int i=0;i<118;i++){

    x[i][2]=x2[i];

}
*/


// transpose de la matrice m
for(int i=0;i<118;i++){
    for(int j=0;j<28;j++){
        x[i][j]=m[j][i];
        cout<<x[i][j];
    }
}

double d;
double alpha = 0.001; // initializing our learning rate
double  e = 2.71828;


double p;
double pred;
double err[118];
double s[28];
double nor;
double b[28];
int sb=27;
for(int col=0;col<sb+1;col++){
          b[col]=1;
        }

//gradient descente

do{
for(int i=0;i<sb+1;i++){
    s[i]=0;
}
 for(int idx=0;idx<118;idx++){
        p=b[0];
        for(int col=1;col<sb+1;col++){
            p = p + b[col] * x[idx][col];
        }
        pred  = 1/(1+ pow(e,-p));
        err[idx] = pred-y[idx];
        for(int z=0;z< sb+1;z++){
            s[z]=s[z]+err[idx]*x[idx][z];
        }

 }
      for(int z=0;z< sb+1;z++){
            s[z]=(1.0/118.0)*s[z];

        }
        for(int z=0;z< sb+1;z++){
            b[z]=b[z]-(alpha *s[z]);
        }
        nor=0.0;
        for(int z=0;z< sb+1;z++){
            nor=nor+pow(s[z],2);
        }
        nor=sqrt(nor);
        cout<<"la norme"<<nor<<endl;

}while(nor>0.01);

//affichage de theta final

cout<<"theta final"<<endl;
for(int i=0;i<sb+1;i++){
    cout<<"theta["<<i<<"]= "<<b[i]<<endl;
}

int t[118];
double tt=0;


//  cost function

for(int i=0;i<118;i++){
        p=b[0];
    for(int col=1;col<sb+1;col++){
            p = p + b[col] * x[i][col];

        }
        pred  =1/ (1+ pow(e,-p));

    tt =tt -(y[i]*log( pred )) - (( 1 - y[i]) * log( 1 - pred ));

}
cpt=0;

//  Accuracy
for(int i=0;i<118;i++){
        p=b[0];
    for(int col=1;col<sb+1;col++){
            p = p + b[col] * x[i][col];

        }
        pred  =1/ (1+ pow(e,-p));

       if(pred>=0.5)
        t[i]=1;
       else
        t[i]=0;

       if(t[i]==y[i])
          cpt++;

}

cout<<"Accuracy :"<<cpt/118.0<<endl;
cout<<"Erreur empirique "<<tt/118.0;


return 1;
}

